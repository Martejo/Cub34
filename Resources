https://lodev.org/cgtutor/raycasting.html
https://medium.com/@afatir.ahmedfatir/cub3d-tutorial-af5dd31d2fcf

1. Compréhension du Ray-Casting

Le ray-casting est une technique fondamentale pour créer une perspective en trois dimensions à partir d'une carte en deux dimensions. Vous devez comprendre comment projeter les rayons depuis la position du joueur pour calculer les intersections avec les murs et ainsi déterminer les textures à afficher.

2. Utilisation de la MinilibX
La MinilibX est une bibliothèque graphique utilisée dans l'écosystème de l'école 42 pour créer des interfaces graphiques de base. Vous devrez l'utiliser pour gérer les fenêtres, dessiner à l'écran et gérer les entrées clavier/souris.

3. Structure du Programme
Parsing: Vous devez être capable de lire et d'analyser les fichiers .cub, qui décrivent la carte et les textures du labyrinthe. La gestion correcte des erreurs pendant le parsing est cruciale.
Graphismes: Utilisation des textures pour les murs en fonction de leur orientation (Nord, Sud, Est, Ouest) et définition des couleurs pour le sol et le plafond.
Contrôles de l'utilisateur: Implémentez les déplacements (W, A, S, D) et les rotations de la caméra (flèches gauche et droite) ainsi que les fonctionnalités pour quitter le jeu (ESC ou clic sur la croix rouge).
4. Règles de Gestion de la Fenêtre
Votre application doit gérer correctement les fenêtres en termes de minimisation et de passage à une autre fenêtre sans perdre l'état ni crasher.

5. Rendu et Performances
Vous devez vous assurer que le rendu de la scène est performant pour éviter les lags ou les saccades, ce qui implique souvent de trouver le bon équilibre entre la qualité visuelle et la vitesse de traitement.

6. Bonus (Si la partie obligatoire est parfaite)
Les fonctionnalités bonus incluent la gestion des collisions, une mini-carte, des portes interactives, des animations et le contrôle de la caméra avec la souris. Ces éléments sont facultatifs mais peuvent grandement enrichir l'expérience utilisateur.

Conseils pour le Développement
Démarrez petit: Commencez par créer un simple moteur de ray-casting qui peut afficher des murs sans textures.
Intégrez progressivement: Ajoutez les textures, puis les contrôles, et enfin les optimisations et les bonus.
Tests continus: Testez chaque fonctionnalité au fur et à mesure de son développement pour s'assurer qu'elle fonctionne correctement dans tous les cas de figure.


Principes de base du ray-casting
Projection de Rayons :
Le ray-casting fonctionne en projetant des rayons depuis la position du joueur à travers le champ de vision. Chaque rayon est testé pour déterminer son intersection avec les obstacles de l'environnement (souvent des murs dans un labyrinthe).
La distance à laquelle un rayon rencontre un obstacle est ensuite utilisée pour calculer la hauteur de la colonne de pixels à afficher à l'écran pour représenter ce mur. Plus l'obstacle est proche, plus la colonne dessinée est haute.
Calcul de Distance :
Pour éviter l'effet "fisheye", où les objets sur les côtés de l'écran semblent courbés et plus grands que ceux au centre, les distances sont corrigées pour être perpendiculaires à la ligne de vue plutôt qu'à l'angle du rayon.
Optimisations :
Les calculs pour chaque rayon sont indépendants, permettant des optimisations telles que le multithreading.
Des techniques comme le "ray stripping" (groupement de rayons adjacents qui frappent le même obstacle) peuvent être utilisées pour réduire le nombre de calculs.
Utilisation des Textures
Dans le ray-casting, les textures sont appliquées aux murs pour augmenter le réalisme. La distance et l'angle d'intersection du rayon avec un mur déterminent quelle partie de la texture est affichée et à quelle échelle. Cela permet de simuler des murs texturés de manière réaliste dans un environnement 3D à partir d'une carte 2D.

Applications
Le ray-casting est principalement utilisé dans les jeux vidéo, en particulier les premiers shooters à la première personne. Il est également utilisé dans certaines applications de visualisation et de simulation où la complexité et les exigences en ressources des rendus 3D complets ne sont pas nécessaires. Bien que largement remplacé par des techniques plus avancées pour les jeux modernes, le ray-casting reste un excellent moyen d'introduction aux concepts de rendu 3D en raison de sa relative simplicité et de ses exigences matérielles minimales.


La gestion de l'ouverture et de la fermeture des portes dans un jeu ou une application qui utilise des graphiques 3D, comme dans un projet de ray-casting, implique plusieurs aspects, y compris la détection de la proximité du joueur, la modification de l'état de la porte (ouverte ou fermée), et le rendu visuel de ces changements. Voici comment vous pourriez aborder la gestion des portes dans un contexte de développement :

1. Détection de la Proximité du Joueur
Vous devez d'abord déterminer quand le joueur est suffisamment proche pour interagir avec une porte. Cela peut être accompli en vérifiant la distance entre le joueur et la porte. Si cette distance est inférieure à un seuil prédéfini, le joueur peut déclencher une action sur la porte (ouvrir ou fermer).

2. Gestion de l'État de la Porte
Chaque porte dans votre jeu doit avoir un état qui peut être changé. Typiquement, cet état pourrait être "ouverte", "fermée", ou "en mouvement" (si vous souhaitez animer l'ouverture et la fermeture des portes).

Variables d'État : Vous pourriez utiliser des variables booléennes ou un énuméré pour gérer ces états.
Changement d'État : Lorsque le joueur effectue une action (par exemple, appuyer sur une touche ou cliquer sur un bouton lorsqu'il est à proximité de la porte), l'état de la porte change. Si la porte est fermée, elle devrait passer à l'état "en mouvement" vers "ouverte", et vice versa.
3. Animation des Portes
Pour rendre l'interaction plus réaliste, vous pouvez animer les portes lorsqu'elles s'ouvrent ou se ferment.

Interpolation : Utilisez des fonctions d'interpolation pour animer la porte. Par exemple, vous pouvez modifier progressivement la position ou l'angle de la porte sur un intervalle de temps pour simuler un mouvement réel.
Temporisation : Définissez une durée pour l'animation, pendant laquelle la porte passe de totalement fermée à totalement ouverte, et utilisez le temps écoulé pour calculer l'état actuel de l'animation.
4. Mise à Jour du Ray-Casting
Lorsque vous utilisez le ray-casting, les portes affectent la manière dont les rayons interagissent avec l'environnement.

Calculs de Collision : Lorsqu'une porte change d'état, vous devez mettre à jour les calculs de collision pour les rayons pour refléter la nouvelle position de la porte.
Rendu : Assurez-vous que les textures de la porte reflètent correctement son ouverture et sa fermeture, ajustant la hauteur ou la visibilité selon l'angle de vue et l'état de la porte.
5. Effets Sonores
Pour augmenter l'immersion, ajoutez des effets sonores appropriés lorsque les portes s'ouvrent ou se ferment. Cela aide à renforcer la réponse de l'utilisateur à l'interaction.

Conseils de Développement
Testez Rigoureusement : Les portes sont des éléments interactifs critiques qui peuvent souvent être source de bugs, notamment dans les calculs de collision et les animations. Testez toutes les situations possibles pour éviter des erreurs.
Gardez le Code Modulaire : Encapsulez la logique des portes dans des classes ou des fonctions spécifiques pour faciliter la maintenance et l'extension du code.


Travailler efficacement en binôme sur GitHub nécessite une bonne organisation, une communication claire, et l'utilisation des bonnes pratiques de développement collaboratif. Voici quelques conseils pour vous aider à gérer votre projet en binôme sur GitHub :

1. Utilisez des Branches
Les branches sont cruciales pour séparer le développement de différentes fonctionnalités sans interférer avec la branche principale (main/master). Chaque fonctionnalité, correction ou ajout devrait être développé dans une branche séparée.

Créer des branches pour chaque fonctionnalité : Nommez les branches de manière explicite (par exemple, feature-door-animation, bugfix-ray-calculation).
Fusionner régulièrement : Une fois la fonctionnalité testée et approuvée, faites une pull request (PR) pour la fusionner avec la branche principale. Utilisez les revues de code pour que chaque binôme puisse vérifier et discuter des changements.
2. Revues de Code
Les pull requests sur GitHub permettent non seulement de fusionner du code mais aussi de le revoir et de le discuter. Utilisez-les pour :

Examiner le code : Chaque membre du binôme doit revoir le code de l'autre pour s'assurer qu'il est propre, compréhensible et sans bugs évidents.
Discuter des modifications : Utilisez les commentaires dans les PR pour poser des questions ou suggérer des améliorations.
3. Communication
Maintenez une communication constante, que ce soit via les issues de GitHub, des outils de messagerie instantanée, ou des réunions régulières.

Définir des objectifs clairs : Assurez-vous que vous et votre binôme êtes clairs sur ce que vous devez faire.
Rapports réguliers : Faites régulièrement le point sur votre avancement et ajustez vos plans si nécessaire.
4. Gestion des Issues
Utilisez les issues de GitHub pour suivre les tâches, les bugs, et les demandes de fonctionnalités.

Créer des issues pour tout : Chaque tâche peut être suivie avec une issue, ce qui permet de s'assurer que rien n'est oublié.
Attribuer des issues : Assurez-vous que chaque issue est attribuée à une personne, évitant ainsi les confusions sur qui fait quoi.
5. Documentation
Documentez tout, des instructions d'installation aux détails des fonctions et des modules.

README.md : Maintenez un fichier README à jour avec des instructions sur comment configurer et lancer le projet.
Commentaires dans le code : Commentez votre code pour expliquer "pourquoi" quelque chose est fait de cette manière, surtout quand ce n'est pas évident.
6. Utilisation de .gitignore
Configurez un fichier .gitignore approprié pour éviter de pousser des fichiers inutiles ou sensibles sur le dépôt (comme des fichiers de configuration locaux, des dossiers node_modules, etc.).

7. Tests Automatisés
Si possible, configurez des tests automatisés pour s'assurer que les nouvelles modifications ne cassent pas les fonctionnalités existantes.

8. Utiliser des Linters et Formatters
Configurez des linters et des formatters pour maintenir un style de code cohérent entre vous et votre binôme.

En suivant ces conseils, vous maximiserez votre efficacité et réduirez les chances de conflits ou de confusions tout en travaillant sur votre projet en binôme sur GitHub.